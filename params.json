{"name":"cf4ocl","tagline":"C Framework for OpenCL","body":"Summary\r\n=======\r\n\r\nThe C Framework for OpenCL (cf4ocl) is a pure C99 set of libraries and\r\nutilities with the goal of facilitating: 1) the rapid development of \r\nOpenCL C programs; 2) the benchmark of OpenCL events, such as kernel \r\nexecution and data transfers; and, 3) analysis of the OpenCL \r\nenvironment and kernel requirements.\r\n\r\ncf4ocl is composed of four parts: i) library; ii) command-line \r\nutilities; iii) unit tests; and, iv) examples. The library offers \r\nfunctions which aim to achieve goals 1) and 2). The command-line \r\nutilities are focused on goal 3). The unit tests aim to verify that the \r\nlibrary functions are working properly. Finally, the examples show how \r\nto integrate the library functions in fully working OpenCL programs.\r\n\r\nThe target platform of cf4ocl is Linux, although, being pure C99, it \r\ncan be compiled to other platforms as long as the dependencies, \r\n[GLib][] and [OpenCL][], are met. The reference compiler is GCC with \r\n`-Wall` and `-Wextra` flags activated. The code is verified with \r\n[cppcheck][] and is fully commented. API documentation can be generated \r\nwith [Doxygen][].\r\n\r\nLibrary code is licensed under [LGPLv3][], while the remaining code is \r\nlicensed under [GPLv3](http://www.gnu.org/licenses/gpl.html).\r\n\r\nTable of contents\r\n=================\r\n\r\n1\\.  [Introduction](#introduction)  \r\n1.1\\.  [Structure](#structure)  \r\n1.2\\.  [Library](#library)  \r\n1.2.1\\.  [CL Utils](#clutils)  \r\n1.2.2\\.  [CL Profiler](#clprofiler)  \r\n1.2.3\\.  [GError framework](#gerrorframework)  \r\n1.3\\.  [Utilities](#utilities)  \r\n1.3.1\\.  [Device query](#devicequery)  \r\n1.3.2\\.  [Kernel info](#kernelinfo)  \r\n2\\.  [How to use cf4ocl](#howtousecf4ocl)  \r\n2.1\\.  [Dependencies](#dependencies)  \r\n2.1.1\\.  [OpenCL](#opencl)  \r\n2.1.2\\.  [GLib](#glib)  \r\n2.2\\.  [Library, utilities, tests and examples](#libraryutilitiestestsandexamples)  \r\n2.3\\.  [Using the library in a new project](#usingthelibraryinanewproject)  \r\n2.3.1\\.  [Compiling and linking](#compilingandlinking)  \r\n2.3.2\\.  [Using CL Utils](#usingclutils)  \r\n2.3.3\\.  [Using CL Profiler](#usingclprofiler)  \r\n2.3.4\\.  [Using GError Framework (GErrorF)](#usinggerrorframeworkgerrorf)  \r\n2.4\\.  [Generating the API documentation](#generatingtheapidocumentation)  \r\n3\\.  [Other useful C frameworks/utilities for OpenCL](#otherusefulcframeworks/utilitiesforopencl)  \r\n\r\n<a name=\"introduction\"></a>\r\n\r\n1\\. Introduction\r\n============\r\n\r\n<a name=\"structure\"></a>\r\n\r\n1.1\\. Structure\r\n---------\r\n\r\n* **Library**\r\n    * CL Utils\r\n    * CL Profiler\r\n    * GError framework\r\n* **Library tests**\r\n    * CL Profiler\r\n    * GError framework\r\n* **Utilities**\r\n    * Device query\r\n    * Kernel info\r\n* **Examples**\r\n    * Bank conflicts test\r\n    * Matrix multiplication\r\n\r\n<a name=\"library\"></a>\r\n\r\n1.2\\. Library\r\n-------\r\n\r\n<a name=\"clutils\"></a>\r\n\r\n### 1.2.1\\. CL Utils\r\n\r\n* Create/initialize OpenCL objects such as platform, device, context, \r\ncommand queues, devices, and so on with just one instruction (also one\r\ninstruction for freeing/releasing these objects).\r\n* Build an OpenCL program with one instruction by passing an array of\r\nfilenames containing the kernels.\r\n* Automatic or manual device selection.\r\n* Doesn't hide OpenCL objects from the client programmer.\r\n\r\n<a name=\"clprofiler\"></a>\r\n\r\n### 1.2.2\\. CL Profiler\r\n\r\n* Get detailed profiling information about OpenCL events, including\r\nrelative and absolute times.\r\n* Supports multiple command queues and overlapping events (e.g. such\r\nas simultaneous kernel execution and data transfer).\r\n\r\n<a name=\"gerrorframework\"></a>\r\n\r\n### 1.2.3\\. GError framework\r\n\r\n* Generic C error handling framework based on GError object from GLib.\r\n* Just two macros.\r\n* Required by CL Utils and CL Profiler.\r\n\r\n<a name=\"utilities\"></a>\r\n\r\n1.3\\. Utilities\r\n---------\r\n\r\n<a name=\"devicequery\"></a>\r\n\r\n### 1.3.1\\. Device query\r\n\r\nSimple implementation of a program for querying available OpenCL\r\nplatforms and devices with clean and useful output.\r\n\r\n<a name=\"kernelinfo\"></a>\r\n\r\n### 1.3.2\\. Kernel info\r\n\r\nStatic analysis of OpenCL kernels.\r\n\r\n<a name=\"howtousecf4ocl\"></a>\r\n\r\n2\\. How to use cf4ocl\r\n=================\r\n\r\n<a name=\"dependencies\"></a>\r\n\r\n2.1\\. Dependencies\r\n------------\r\n\r\nIn order to compile cf4ocl and use it in projects, two dependencies are\r\nrequired: 1) [OpenCL][]; and, 2) [GLib][] (v2.32 or newer).\r\n\r\n<a name=\"opencl\"></a>\r\n\r\n### 2.1.1\\. OpenCL\r\n\r\nThe OpenCL headers (for compiling) and shared library (for linking) can\r\nbe installed from the packages offered by different OpenCL vendors such\r\nas [AMD][AMDSDK], [Intel][IntelSDK] or [Nvidia][NvidiaSDK]. \r\n\r\nAlternatively, it is possible to install an OpenCL development \r\nenvironment in a some recent Linux distributions. For example, in Debian\r\n7 and Ubuntu 13.04:\r\n\r\n    $ sudo apt-get install ocl-icd-opencl-dev\r\n\r\nThis will install the headers and shared library system-wide, avoiding \r\nthe need to specify their location to GCC. However, to actually run an \r\nOpenCL program it is necessary to have a vendor implementation \r\ninstalled.\r\n\r\n<a name=\"glib\"></a>\r\n\r\n### 2.1.2\\. GLib\r\n\r\nThe simplest way to install [GLib][] is using the package manager of\r\nthe Linux distribution. For Debian and Ubuntu:\r\n\r\n    $ sudo apt-get install libglib2.0-dev\r\n    \r\nIt is also advisable to install the `libglib2.0-0-dbg` or equivalent\r\npackage to allow debugging at the GLib level.\r\n\r\n<a name=\"libraryutilitiestestsandexamples\"></a>\r\n\r\n2.2\\. Library, utilities, tests and examples\r\n--------------------------------------\r\n\r\nAssuming a working development environment with OpenCL and GLib \r\nproperly setup, to build everything it is simply necessary to run `make`\r\nwithin the cf4ocl directory.\r\n\r\nIt is possible to build only specific targets, for example:\r\n\r\n    $ make library\r\n    $ make utils\r\n    $ make tests\r\n    $ make examples\r\n\r\nIf the build failed, confirm if OpenCL and GLib are properly installed,\r\nand if GCC can find the OpenCL headers and shared library. If not,\r\nset the headers location in the `CLINCLUDES` Makefile variable, and set\r\nthe shared library location in the `CLLIBDIR` Makefile variable.\r\n\r\n<a name=\"usingthelibraryinanewproject\"></a>\r\n\r\n2.3\\. Using the library in a new project\r\n----------------------------------\r\n\r\nAny of the three elements of the library can be used in a workflow\r\nwithout the need to use the others. However, both CL Utils and CL \r\nProfiler internally use the GError framework.\r\n\r\n<a name=\"compilingandlinking\"></a>\r\n\r\n### 2.3.1\\. Compiling and linking\r\n\r\nWhen building a program based on cf4ocl (or any OpenCL program) with \r\nGCC, it may be necessary to specify the location of the OpenCL headers \r\nwith the `-I` flag, and the location of the shared library \r\n(libOpenCL.so) with the `-L` flag. If the OpenCL development files were\r\ninstalled from the package manager (e.g. the `ocl-icd-opencl-dev` \r\npackage in Debian and Ubuntu), this is usually not required.\r\n\r\nAdditionally, in order to **compile** a program with GLib (required by \r\ncf4ocl), the following line should be added to the GCC syntax:\r\n\r\n    `pkg-config --cflags glib-2.0`\r\n    \r\nIn order to **link** a program with GLib, it is necessary to add the \r\nfollowing line to the GCC syntax:\r\n\r\n    `pkg-config --libs glib-2.0`\r\n\r\nThese two lines will expand correctly to the `-I` and `-l` flags \r\nrequired for compiling and linking, respectively.\r\n\r\n<a name=\"usingclutils\"></a>\r\n\r\n### 2.3.2\\. Using CL Utils\r\n\r\nThe functions provided by CL Utils aim to facilitate the rapid \r\ndevelopment and deployment of C programs which use OpenCL. These \r\nfunctions are focused on two key tasks:\r\n\r\n1. Setup and tear down of the OpenCL environment, including device,\r\ncontext and command queues.\r\n\r\n2. Loading, compilation and tear down of OpenCL kernel programs.\r\n\r\nThese two tasks require very verbose code, with significant repetition \r\nbetween projects. CL Utils wraps these tasks into two functions,\r\nproviding an additional third function for freeing up the allocated\r\nresources. The OpenCL objects created by CL Utils are available to\r\nthe client programmer at all times through the `CLUZone` object. \r\nCL Utils does not wrap any other OpenCL tasks, such as kernel execution \r\nor data transfers, which can be performed directly with the respective \r\nOpenCL functions.\r\n\r\nThe first task is performed with the `clu_zone_new` function, which\r\nhas the following prototype:\r\n\r\n```c\r\nCLUZone* clu_zone_new(\r\n    /* Type of device, e.g. CL_DEVICE_TYPE_CPU, CL_DEVICE_TYPE_GPU, etc. */\r\n    cl_uint deviceType,\r\n    /* Number of command queues. */\r\n    cl_uint numQueues,\r\n    /* Command queue properties, e.g. CL_QUEUE_PROFILING_ENABLE, etc. */\r\n    cl_int queueProperties,\r\n    /* Pointer to a device selector function. */\r\n    clu_device_selector devSel, \r\n    /* Extra arguments for device selector function. */\r\n    void* dsExtraArg, \r\n    /* GLib's error reporting object (may be ignored). */\r\n    GError **err\r\n);\r\n```\r\n\r\nThe returned `CLUZone` object will contain the context, command queues,\r\ndevice information and an uninitialized kernel program. The program is\r\ninitialized with the `clu_program_create` function as part of the second \r\ntask. This function has the following prototype:\r\n\r\n```c\r\ncl_int clu_program_create(\r\n    /* The CLUZone object return by the clu_zone_new function. */\r\n    CLUZone* zone, \r\n    /* List of files containing the source code for the kernels. */\r\n    const char** kernelFiles, \r\n    /* Number of kernel files given in the previous parameter. */\r\n    cl_uint numKernelFiles, \r\n    /* Compiler options. */\r\n    const char* compilerOpts, \r\n    /* GLib's error reporting object (may be ignored). */\r\n    GError **err\r\n);\r\n```\r\n\r\nA typical usage pattern of CL Utils in a C program:\r\n\r\n```c\r\ninclude \"clutils.h\"\r\n\r\n...\r\n\r\nint main(int argc, char* argv[]) \r\n{\r\n    ...\r\n    CLUZone* zone = NULL;\r\n    const char* oclSources[] = {\"src1.cl\", \"src2.cl\", \"moresrc.cl\"};\r\n    ...\r\n\r\n    /* Get a complete OpenCL environment using a GPU device, one  */\r\n    /* command queue, no command queue options, if more than one  */ \r\n    /* GPU is available show selection menu to user, and ignore   */\r\n    /* error reporting. */\r\n    zone = clu_zone_new(CL_DEVICE_TYPE_GPU, 1, 0, clu_menu_device_selector, NULL, NULL);\r\n    ...\r\n\r\n    /* Create (compile) an OpenCL kernel program using three OpenCL */\r\n    /* source files, no compiler options, and ignoring error        */\r\n    /* reporting.                                                   */\r\n    status = clu_program_create(zone, oclSources, 3, NULL, NULL);\r\n    ...\r\n\r\n    /* Perform OpenCL tasks such as data transfer and kernel execution */\r\n    /* using the OpenCL objects (queues, program, context, etc.)       */\r\n    /* available within the CLUZone object.                            */\r\n    ...\r\n\r\n    /* Free the CLUZone object and all of the contained OpenCL objects.*/\r\n    /* This object should only be released after all OpenCL objects    */\r\n    /* not controlled by CL Utils (kernels, events, memory objects)    */\r\n    /* are released.                                                   */\r\n    clu_zone_free(zone);\r\n\r\n    ...\r\n\r\n}\r\n```\r\n\r\nThe fourth parameter of `clu_zone_new` is a pointer to a device \r\nselector function, which has the following definition:\r\n\r\n```c\r\ntypedef cl_uint (*clu_device_selector)(\r\n    /* Array of available devices and respective information. */\r\n    CLUDeviceInfo* devInfos,\r\n    /* Number of devices in array. */\r\n    cl_uint numDevices, \r\n    /* Extra arguments to selector function. */\r\n    void* extraArg\r\n);\r\n```\r\n\r\nCL Utils provides two ready to use device selector functions:\r\n\r\n* `clu_menu_device_selector` - If more than one device exists, presents\r\na selection menu to the user. If extra argument is given it should be \r\nthe array index of the preferred device.\r\n* `clu_info_device_selector` - Selects a device by device name, device\r\nvendor and/or platform name, any/all of which are given in the extra\r\nargument.\r\n\r\nFor other device selection requirements, the client programmer can \r\ndevelop a specific device selector function.\r\n\r\n<a name=\"usingclprofiler\"></a>\r\n\r\n### 2.3.3\\. Using CL Profiler\r\n\r\nThe goal of CL Profiler is to provide detailed benchmarking information \r\nabout OpenCL events such as kernel execution, data transfers, and so on.\r\nCL Profiler is prepared to handle overlapping events, which usually\r\ntake place when the programmer is trying to optimize its application\r\nby simultaneously transfer data to and from the OpenCL device and \r\nexecute kernels, using different command queues.\r\n\r\nCL Profiler consists of two files, `clprofiler.c` and `clprofiler.h`.\r\nIn order to use CL Profiler in a project, it is necessary to include\r\nthe `clprofiler.h` header file.\r\n\r\nFor the purpose of this explanation, we will consider that two command \r\nqueues are being used:\r\n\r\n```c\r\ncl_command_queue queue0; /* Used for host-device data transfer. */\r\ncl_command_queue queue1; /* Used for kernel execution. */\r\n```\r\n\r\nAdditionally, we will consider the following OpenCL events:\r\n\r\n```c\r\ncl_event ev_transf_in;  /* Transfer data from host to device. */\r\ncl_event ev_kernel_A_1; /* Execute kernel A on device. */\r\ncl_event ev_kernel_B;   /* Execute kernel B on device. */\r\ncl_event ev_kernel_A_2; /* Execute kernel A on device again. */\r\ncl_event ev_transf_out; /* Transfer data from device to host. */\r\n```\r\n\r\nThe `ProfCLProfile` structure forms the basis of CL Profiler. It can:\r\n1) measure the total elapsed time of the application (or the relevant \r\npart of the application); and, 2) keep track of the device time required\r\nby the OpenCL events. The following instruction creates a new \r\n`ProfCLProfile` structure:\r\n\r\n```c\r\n/* Create a new ProfCLProfile structure. */\r\nProfCLProfile* profile = profcl_profile_new();\r\n```\r\n\r\nIn order to start measuring the relevant part of the application, the\r\nfollowing instruction should be issued:\r\n\r\n```c\r\n/* Start basic timming / profiling. */\r\nprofcl_profile_start(profile);\r\n```\r\n\r\nAt this time, the typical OpenCL application workflow, such as \r\ntransferring data and executing kernels, should take place. The above \r\ndefined events must be associated with the respective `clEnqueue*` \r\nOpenCL functions in order to be later analyzed. A typical workflow \r\nmay be finalized with the following instructions:\r\n\r\n```c\r\n/* Finish all pending OpenCL operations. */\r\nclFinish(queue0);\r\nclFinish(queue1);\r\n```\r\n\r\nProfiling should be stopped at this point.\r\n\r\n```c\r\nprofcl_profile_stop(profile); \r\n```\r\n\r\nNow the events can be added to the profiler structure. The\r\n`profcl_profile_add` function uses the second parameter (a string)\r\nas a key to differentiate between events. Thus, if the same key\r\nis given for different OpenCL events, CL Profiler will consider \r\nit to be the same _semantic_ event. This can be useful for aggregating\r\nexecution times of events which occur innumerous times in a cyclic \r\nfashion (in a _for_ loop, for example). \r\n\r\n```c\r\n/* Add events to be profiled/analyzed. */\r\nprofcl_profile_add(profile, \"Transfer data to device\", ev_transf_in, NULL);\r\nprofcl_profile_add(profile, \"Kernel A\", ev_kernel_A_1, NULL);\r\nprofcl_profile_add(profile, \"Kernel B\", ev_kernel_B, NULL);\r\nprofcl_profile_add(profile, \"Kernel A\", ev_kernel_A_2, NULL);\r\nprofcl_profile_add(profile, \"Transfer data from device\", ev_transf_out, NULL);\r\n```\r\n\r\nThe above code will consider OpenCL events `ev_kernel_A_1` and `ev_kernel_A_2`\r\nto be the same semantic event because the same key, string _Kernel A_, is\r\nused. Thus, the total execution time for the semantic event _Kernel A_ will \r\nbe the sum of respective two OpenCL events. CL Profiler can even\r\ndetermine overlaps of a semantic event with itself (i.e., two overlapping\r\nOpenCL events which are added for analysis with the same key).\r\n\r\nAfter all the events are added, it is necessary to instruct CL \r\nProfiler to perform the required calculations in order to determine\r\nthe absolute and relative times of all events, and how these correlate\r\nwith the total elapsed time of the relevant part of the application.\r\n\r\n```c\r\nprofcl_profile_aggregate(profile, NULL);\r\n```\r\n\r\nFinally, the complete benchmarking info can be printed:\r\n\r\n```c\r\nprofcl_print_info(profile, PROFCL_AGGEVDATA_SORT_TIME, NULL);\r\n```\r\n\r\nTwo detailed tables will be printed: one for individual events (sorted by \r\nname or execution time), and another showing event overlaps, if any occurred.\r\n\r\nOnly at this time should the OpenCL events be freed.\r\n\r\n```c\r\nclReleaseEvent(ev_transf_in);\r\nclReleaseEvent(ev_kernel_A_1);\r\nclReleaseEvent(ev_kernel_B);\r\nclReleaseEvent(ev_kernel_A_2);\r\nclReleaseEvent(ev_transf_out);\r\n```\r\n\r\nThe last parameter of some of the `profcl_*` functions is used for error \r\nhandling and to obtain detailed error messages if an error occurs. By \r\npassing `NULL`, the programmer choses to ignore that feature. Such approach \r\nis not critical because all of the error-prone `profcl_*` functions also return\r\ntheir execution status code. No error handling is performed in this \r\nexplanation, though.\r\n\r\nFor map events, CL Profiler provides the `profcl_profile_add_composite`\r\nfunction, which accepts two OpenCL events, one relative to the _map_\r\noperation, and the other to the _unmap_ operation. The function uses\r\nthe start instant of the _map_ event, and the _end_ instant of the\r\n_unmap_ event, in order to build a composite semantic event.\r\n\r\n<a name=\"usinggerrorframeworkgerrorf\"></a>\r\n\r\n### 2.3.4\\. Using GError Framework (GErrorF)\r\n\r\nThe main purpose of GErrorF is to provide error handling constructs to \r\nCL Utils and CL Profiler. No knowledge of GErrorF is required to use\r\nCL Utils and/or CL Profiler. However, because it is sufficiently generic \r\nto be used in any C application, a specific description is warranted.\r\n\r\nGErrorF uses GLib's `GError` object for function error reporting. This\r\nexplanation assumes some familiarity with \r\n[GLib's error reporting][gliberror].\r\n\r\nGErrorF is defined by two macros in `gerrorf.h`:\r\n\r\n* `gef_if_error_create_goto` - Catches errors from non-GError aware\r\nfunctions.\r\n* `gef_if_error_goto` - Catches errors from GError aware functions.\r\n\r\nGErrorF establishes an error handling methodology for C programs not\r\nentirely dissimilar to the pattern used in Linux kernel development. \r\nAny function producing recoverable runtime errors, from `main` to \r\nfunctions located deeper in the call stack, can benefit from this \r\napproach. The general usage of GErrorF is as follows:\r\n\r\n```c\r\ninclude \"gerrorf.h\";\r\n\r\n...\r\n\r\nint main(int argc, char* argv[]) \r\n{\r\n\r\n    ...\r\n\r\n    /* Must initialize every allocable pointers and objects */\r\n    /* to NULL.                                             */\r\n    int some_vector* = NULL;\r\n\r\n    /* GError object. */\r\n    GError *err = NULL;\r\n\r\n    /* Function return status. */\r\n    int status = SUCCESS_CODE;\r\n\r\n    ...\r\n\r\n    /* Call a GError aware function (defined bellow). */\r\n    some_function(params, &err);\r\n\r\n    /* Catch possible error in GError-aware function. In this */\r\n    /* case the GError object is initialized by the called    */\r\n    /* function.                                              */\r\n    gef_if_error_goto(\r\n        err,              /* GError object. */\r\n        SOME_ERROR_CODE,  /* Error code to set in status. */\r\n        status,           /* Function return status. */\r\n        error_handler     /* Label to goto in case of error. */\r\n    );\r\n\r\n    /* In the previous function it is possible to replace an app */\r\n    /* specific error code with GErrorF special constants        */\r\n    /* GEF_USE_STATUS and GEF_USE_GERROR. The former leaves the  */\r\n    /* status variable untouched (useful for cases where the     */\r\n    /* function itself returns a usable int status), while the   */\r\n    /* later sets status to the error code set in the GError     */\r\n    /* object. */\r\n\r\n    ...\r\n\r\n    /* Call a non-GError aware function. */\r\n    some_vector = (int*) malloc(sizeof(int) * SOME_SIZE);\r\n\r\n    /* Catch possible error in non-GError aware function. */\r\n    gef_if_error_create_goto(\r\n        err,                    /* GError object.                  */\r\n        SOME_QUARK_ERROR,       /* GLib GQuark identifier.         */\r\n        some_vector == NULL,    /* Error condition.                */\r\n        SOME_ERROR_CODE,        /* Error code to set in err.       */\r\n        error_handler,          /* Label to goto in case of error. */\r\n        \"Unable to alloc. mem.\" /* Error msg to set in err.        */\r\n    );\r\n\r\n    ...\r\n\r\n    /* If we get here, there was no error, goto cleanup. */\r\n    g_assert(err == NULL);  /* Make sure err is NULL. */\r\n    goto cleanup;           /* Goto the cleanup section. */\r\n\t\r\nerror_handler:\r\n    /* If we got here there was an error, verify that it is so. */\r\n    g_assert (err != NULL);\r\n    /* Print error message. */\r\n    fprintf(stderr, \"Error message: %s\\n\", err->message);\r\n    /* Make sure function status contains an error code. */\r\n    if (status == SUCCESS_CODE) status = err->code; \r\n    /* Free the GError object. */\r\n    g_error_free(err);\r\n\r\ncleanup:\t\r\n    /* Free any allocated memory. */\r\n    if (some_vector) free(some_vector);\r\n\r\n    ...\r\n\r\n    /* Return program status. */\r\n    return status;\r\n}\r\n\r\n...\r\n\r\n/* This function is GError-aware, and will initialize the GError */\r\n/* object if an error occurs. The GError object usually comes    */\r\n/* as the last parameter.                                        */\r\nvoid some_function(some params, GError** err) \r\n{\r\n\r\n    ...\r\n\r\n    FILE* fp;\r\n    const char* filename = \"somefile.txt\";\r\n\r\n    ...\r\n\r\n    /* Try to open a file. This function is not GError aware. */\r\n    fp = fopen(filename, \"r\");\r\n\r\n    /* Catch possible error in non-GError aware function. */\r\n    gef_if_error_create_goto(\r\n        *err,                     /* GError object.                  */\r\n        SOME_QUARK_ERROR,         /* GLib GQuark identifier.         */\r\n        fp == NULL,               /* Error condition.                */\r\n        SOME_ERROR_CODE,          /* Error code to set in err.       */\r\n        error_handler,            /* Label to goto in case of error. */\r\n        \"Unable to open file %s\", /* Error msg to set in err.        */\r\n        filename                  /* Extra args for error msg.       */\r\n    );\r\n\r\n    ...\r\n\r\n    /* If we got here, everything is OK.                          */\r\n    /* It's good practice to check if err is NULL (caller doesn't */\r\n    /* care about error reporting OR if a non-null err is         */\r\n    /* pointing to NULL (i.e. no error was reported).             */\r\n    g_assert (err == NULL || *err == NULL);\r\n\r\n    /* Goto finish label, ignoring the error handling section.    */\r\n    goto finish;\r\n\r\nerror_handler:\r\n    /* If we got here there was an error, verify that it is so,   */\r\n    /* i.e. either the caller doesn't care about error reporting, */\r\n    /* in which case err is NULL, OR a non-null err is in fact    */\r\n    /* pointing to an initialized GError object.                  */\r\n    g_assert (err == NULL || *err != NULL);\r\n\r\n    /* Run any other error handling code. */\r\n    ...\r\n\r\nfinish:\t\r\n\r\n    /* Close the file, if open. */\r\n    if (fp) fclose(fp);\r\n\r\n    /* Perform additional required cleanup (free's and so on). */\r\n    ...\r\n    \r\n    /* Bye. */\r\n    return;\r\n\r\n}\r\n\r\n```\r\n\r\nAs can be observed, GErrorF enforces a strict programming pattern, \r\nwhich requires that complying functions follow a set of rules:\r\n\r\n* Define all pointers and objects in the beginning of the function \r\nand initialize them to NULL.\r\n* Define a pointer to a GError object and set it to NULL.\r\n* Always test for errors after calls to error throwing functions\r\nwith `gef_if_error_create_goto` (non-GError aware functions) or\r\n`gef_if_error_goto` (GError aware functions). If an error occurs\r\nprogram execution will jump to the error handling block.\r\n* Use the following pattern at the end of the function:\r\n    * goto cleanup\r\n    * error handling block\r\n    * cleanup: perform clean up\r\n    * return (possibly with a status code)\r\n\r\nThis pattern avoids many bugs and makes error catching and handling\r\npossible in C. However it is not to everyone's taste, and is thus\r\na completely optional aspect of cf4ocl.\r\n\r\n<a name=\"generatingtheapidocumentation\"></a>\r\n\r\n2.4\\. Generating the API documentation\r\n--------------------------------\r\n\r\nThe API documentation can be generated with `make` if [Doxygen][] \r\n(version 1.8 or newer) is installed. In the cf4ocl directory run:\r\n\r\n    $ make docs\r\n    \r\nThe documentation will be generated in the `./doc` folder. The direct\r\nuse of the `doxygen` command should be avoided because \r\n[Doxygen's markdown][doxymd] is not 100% compatible with the \r\n[GitHub Flavored Markdown][ghmd] used in this document. When building \r\nthe documentation with `make`, the required conversion is performed \r\nfirst.\r\n\r\n<a name=\"otherusefulcframeworks/utilitiesforopencl\"></a>\r\n\r\n3\\. Other useful C frameworks/utilities for OpenCL\r\n==============================================\r\n\r\nIf cf4ocl does not meet your requirements, take a look at the following\r\nprojects:\r\n\r\n* [Simple OpenCL][]\r\n* [The OpenCL utility library][]\r\n* [Computing Language Utility][]\r\n* [OCL-MLA][]\r\n\r\n<!---\r\nConclusions\r\nReferences\r\nAppendices\r\n-->\r\n\r\n[GLib]: https://developer.gnome.org/glib/ \"GLib\"\r\n[OpenCL]: http://www.khronos.org/opencl/ \"OpenCL\"\r\n[Doxygen]: http://www.doxygen.org/â€Ž \"Doxygen\"\r\n[cppcheck]: http://cppcheck.sourceforge.net/ \"cppcheck\"\r\n[LGPLv3]: http://www.gnu.org/licenses/lgpl.html) \"LGPLv3\"\r\n[GPLv3]: http://www.gnu.org/licenses/gpl.html \"GPLv3\"\r\n[AMDSDK]: http://developer.amd.com/tools-and-sdks/heterogeneous-computing/amd-accelerated-parallel-processing-app-sdk/ \"AMD\"\r\n[IntelSDK]: http://software.intel.com/en-us/vcsource/tools/opencl-sdk \"Intel\"\r\n[NvidiaSDK]: https://developer.nvidia.com/category/zone/cuda-zone \"Nvidia\"\r\n[clheaders]: http://www.khronos.org/registry/cl/ \"Khronos\"\r\n[markdown]: http://daringfireball.net/projects/markdown/ \"Markdown\"\r\n[doxymd]: http://www.stack.nl/~dimitri/doxygen/manual/markdown.html \"Doxygen Markdown\"\r\n[ghmd]: https://help.github.com/articles/github-flavored-markdown \"Github Flavored Markdown\"\r\n[gliberror]: https://developer.gnome.org/glib/2.32/glib-Error-Reporting.html \"GLib Error Reporting\"\r\n\r\n[Simple OpenCL]: http://code.google.com/p/simple-opencl/ \"Simple OpenCL\"\r\n[The OpenCL utility library]: https://github.com/Oblomov/CLU \"The OpenCL utility library\"\r\n[Computing Language Utility]: https://github.com/Computing-Language-Utility/CLU \"Computing Language Utility\"\r\n[OCL-MLA]: http://tuxfan.github.io/ocl-mla/ \"OCL-MLA\"\r\n","google":"UA-42378595-1","note":"Don't delete this file! It's used internally to help with page regeneration."}